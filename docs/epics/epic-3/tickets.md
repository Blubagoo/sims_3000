# Epic 3: Terrain System - Tickets

**Epic Goal:** Establish the world foundation: dense terrain data grid, deterministic procedural generation, terrain queries, modification operations, chunked heightmap mesh rendering, water rendering, vegetation/decoration instancing, LOD/culling integration, and multiplayer serialization
**Created:** 2026-01-28
**Canon Version:** 0.13.0
**Planning Agents:** Systems Architect, Graphics Engineer, Game Designer

---

## Revision History

| Date | Canon Change | Summary |
|------|-------------|---------|
| 2026-01-28 | v0.5.0 | Initial ticket creation from three-agent analysis and resolved discussion |
| 2026-01-29 | canon-verification (v0.5.0 â†’ v0.13.0) | No changes required |

> **Verification Note (2026-01-29):** Verified against canon v0.13.0. No changes required. ITerrainQueryable, ITerrainRenderData, ITerrainModifier interfaces align with interfaces.yaml. Terrain contamination sources (ticket 3-018) correctly implement bulk query pattern for IContaminationSource. Dense grid exception pattern documented consistently in patterns.yaml.

---

## Summary

Epic 3 establishes the visual and simulation foundation of the ZergCity world. The terrain covers every tile on the map, is the most-depended-upon ECS system in the project (consumed by 6+ downstream systems), and is the first system to bridge game-state data to the GPU rendering pipeline at scale.

**Key Design Decisions (Resolved):**
- Dense 2D TerrainGrid array (NOT per-entity ECS), 4 bytes per tile
- 32x32 tile chunks aligned with Epic 2 spatial partitioning (ticket 2-050)
- Chunked heightmap mesh with per-vertex terrain_type (not instanced quads)
- Separate semi-transparent water mesh (alpha 0.7-0.8), not part of terrain mesh
- Hard terrain type boundaries (no blending) -- fits toon aesthetic
- Vegetation: instanced low-poly glTF models, placement generated by rendering from tile coords
- Row-major memory layout for game logic; rendering copies chunk-local data during rebuild
- Event-based change notification (TerrainModifiedEvent + dirty flags)
- Water body IDs assigned during generation; flow direction per river tile
- Purge = instant, Grade = multi-tick, Terraform = multi-tick (long)
- Server-authoritative terrain modification, deterministic generation
- Seed visible after game start, not during site selection
- Sea level NOT player-adjustable (reserved for disasters, Epic 13)
- Terrain emissive hierarchy: terrain max 0.60 (prisma_fields), buildings 0.5-1.0
- 3 terrain LOD levels, vegetation only at LOD 0
- Semi-transparent water with shoreline glow, blight mire glow (no fog until polish)

**Target Metrics:**
- Generation time: <100ms (128x128), <500ms (256x256), <2s (512x512)
- All core queries: O(1) or pre-computed
- Terrain draw calls: 25-70 (chunks + water + vegetation)
- Terrain triangles: 38k-98k visible (within Epic 2's <100k budget with LOD)
- Terrain GPU memory: 17-66 MB (3-13% of min spec 512MB)
- CPU terrain memory: ~81KB (128x128), ~321KB (256x256), ~1.26MB (512x512)

---

## Ticket List

### Group A: Data Infrastructure

---

### Ticket 3-001: TerrainType Enum and TerrainComponent Structure

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** S
**Status:** NEW

**Description:**
Define the foundational terrain data types. TerrainType enum with 10 canonical alien types. TerrainComponent struct at exactly 4 bytes per tile: terrain_type (uint8), elevation (uint8, 0-31), moisture (uint8, 0-255), flags (uint8 with bit fields for is_cleared, is_underwater, is_coastal, is_slope, plus 4 reserved bits). This structure is the atomic unit of terrain data that every other ticket builds upon.

**Acceptance Criteria:**
- [ ] TerrainType enum defined with 10 types: Substrate(0), Ridge(1), DeepVoid(2), FlowChannel(3), StillBasin(4), BiolumeGrove(5), PrismaFields(6), SporeFlats(7), BlightMires(8), EmberCrust(9)
- [ ] TerrainComponent struct is exactly 4 bytes (verified with static_assert)
- [ ] Flag bit definitions documented: bit 0 = is_cleared, bit 1 = is_underwater, bit 2 = is_coastal, bit 3 = is_slope, bits 4-7 reserved
- [ ] Elevation range 0-31 enforced (5 bits effective, stored in uint8)
- [ ] Unit tests for flag manipulation helpers (set, clear, test individual bits)

**Dependencies:**
- Blocked by: None (foundational)
- Blocks: 3-002, 3-003, 3-004, 3-005, 3-010, 3-014

**Agent Notes:**
- Systems Architect: 4 bytes per tile is critical for cache performance. 512x512 at 4B/tile = 1MB, fits in L2 cache for linear traversal.
- Game Designer: All 10 types must use canonical alien terminology (substrate, ridge, deep_void, flow_channel, still_basin, biolume_grove, prisma_fields, spore_flats, blight_mires, ember_crust).

---

### Ticket 3-002: TerrainGrid Dense Array Storage

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** M
**Status:** NEW

**Description:**
Implement the TerrainGrid dense 2D array that stores all tile data. Row-major layout (x varies fastest within a row). Supports configurable map sizes (128x128, 256x256, 512x512 -- square maps only). O(1) coordinate-to-tile access. Bounds checking. This is NOT per-entity ECS storage; TerrainSystem manages this data structure internally.

**Acceptance Criteria:**
- [ ] TerrainGrid struct with width, height, tiles vector, sea_level (uint8, default 8)
- [ ] Row-major storage: index = y * width + x
- [ ] at(x, y) accessor with bounds checking in debug builds
- [ ] in_bounds(x, y) returns false for out-of-range coordinates
- [ ] Supports 128x128, 256x256, 512x512 map sizes
- [ ] Memory budget verified: 64KB / 256KB / 1MB for respective sizes
- [ ] Unit tests for coordinate access, bounds checking, and edge tiles

**Dependencies:**
- Blocked by: 3-001 (TerrainComponent definition)
- Blocks: 3-003, 3-006, 3-007, 3-008, 3-009, 3-014, 3-016, 3-017, 3-027

**Agent Notes:**
- Systems Architect: Row-major is optimal for generation (row-by-row iteration) and game logic queries. Rendering copies chunk-local data (32x32 = ~4KB per chunk) during mesh rebuild -- trivial cost.
- Graphics Engineer: Rendering reads this data via ITerrainRenderData interface. Row-major is acceptable; chunk extraction is fast.

---

### Ticket 3-003: TerrainTypeInfo Static Lookup Table

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** S
**Status:** NEW

**Description:**
Define the static lookup table of per-terrain-type gameplay and rendering properties. Single source of truth for: buildable, clearable, costs, value modifiers, contamination, harmony, emissive color, emissive intensity. Both TerrainSystem (gameplay) and RenderingSystem (visuals) reference this table.

**Acceptance Criteria:**
- [ ] TerrainTypeInfo struct defined with all fields: buildable, clearable, generates_contamination, clear_cost, clear_revenue, build_cost_modifier, value_bonus, harmony_bonus, emissive_color (Vec3), emissive_intensity (float)
- [ ] Static array TERRAIN_INFO[10] populated with design values
- [ ] Emissive intensity hierarchy respected: max terrain = 0.60 (PrismaFields), min = 0.05 (Substrate)
- [ ] Game Designer-approved values for all gameplay modifiers
- [ ] Unit tests verifying table completeness and consistency

**Dependencies:**
- Blocked by: 3-001 (TerrainType enum)
- Blocks: 3-014, 3-016, 3-025, 3-030

**Agent Notes:**
- Systems Architect: This table is the single source of truth. Changes here ripple to both gameplay and rendering.
- Graphics Engineer: Emissive values feed into the terrain shader uniform buffer (10-entry palette). PrismaFields at 0.60 produces intentional bloom bleed (~1-2px radius).
- Game Designer: Prisma fields rarest (2-4%), substrate most common (35-45%). Emissive intensity calibrated below building glow (0.5-1.0) to maintain hierarchy.

---

### Ticket 3-004: TerrainModifiedEvent and Dirty Flag System

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** S
**Status:** NEW

**Description:**
Define the event structure for terrain change notification and the per-chunk dirty flag tracking system. TerrainModifiedEvent carries the affected tile range (GridRect) and modification type enum. Dirty flags per 32x32 chunk enable RenderingSystem to rebuild only affected chunks. Supports both event-based notification (primary) and dirty flag polling (fallback).

**Acceptance Criteria:**
- [ ] TerrainModifiedEvent struct with GridRect affected_area and ModificationType enum (Cleared, Leveled, Terraformed, Generated, SeaLevelChanged)
- [ ] Per-chunk dirty flag array (bool per 32x32 chunk)
- [ ] mark_chunk_dirty(chunk_x, chunk_y) sets flag
- [ ] is_chunk_dirty(chunk_x, chunk_y) queries flag
- [ ] clear_chunk_dirty(chunk_x, chunk_y) clears after render rebuild
- [ ] TerrainModifiedEvent automatically marks affected chunks dirty
- [ ] Chunk grid size derived from map size (e.g., 512/32 = 16x16 chunk grid)
- [ ] Unit tests for dirty flag propagation from tile coordinates to chunk coordinates

**Dependencies:**
- Blocked by: 3-001 (TerrainComponent for modification types)
- Blocks: 3-019, 3-020, 3-021, 3-025, 3-031

**Agent Notes:**
- Systems Architect: Event-based is primary; dirty polling is fallback per ITerrainRenderData interface. At most 1 chunk rebuilt per frame to avoid GPU stalls.
- Graphics Engineer: 32x32 chunks align with Epic 2 spatial partitioning (ticket 2-050). Chunk rebuild queued and processed over multiple frames.

---

### Ticket 3-005: Water Body Identification and Flow Direction Storage

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** M
**Status:** NEW

**Description:**
Extend terrain data storage to track discrete water bodies and per-tile river flow direction. Each contiguous water region gets a unique body ID (computed during generation). River tiles store flow direction as an 8-direction enum. This data enables single-mesh-per-body water rendering and directional UV scrolling for flow channels.

**Acceptance Criteria:**
- [ ] WaterBodyID type (uint16, 0 = no water body)
- [ ] FlowDirection enum (8 cardinal + diagonal directions, plus None)
- [ ] Separate dense grid for water_body_id (same dimensions as TerrainGrid)
- [ ] Separate dense grid for flow_direction (only meaningful for FlowChannel tiles)
- [ ] get_water_body_id(x, y) query
- [ ] get_flow_direction(x, y) query
- [ ] Memory overhead: 3 bytes per tile (2 body ID + 1 flow direction) = 768KB at 512x512
- [ ] Unit tests for water body assignment and flow direction queries

**Dependencies:**
- Blocked by: 3-001 (TerrainType enum for water types)
- Blocks: 3-009, 3-027, 3-028

**Agent Notes:**
- Systems Architect: Water body IDs assigned during generation via flood-fill. Flow direction computed from elevation gradient descent during river placement.
- Graphics Engineer: Needs contiguous body info for single-mesh water generation. Flow direction drives UV scroll direction in water shader.

---

### Ticket 3-006: Water Distance Field Pre-computation

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** M
**Status:** NEW

**Description:**
Pre-compute a uint8 distance-to-nearest-water grid using BFS from all water tiles. Distance capped at 255 tiles. Computed during generation and recomputed on water body changes. Critical performance optimization: FluidSystem, LandValueSystem, and PortSystem all need water proximity queries. Without pre-computation, these queries are O(n) per tile.

**Acceptance Criteria:**
- [ ] Separate uint8 grid storing distance to nearest water tile
- [ ] BFS-based computation from all water tiles simultaneously (multi-source BFS)
- [ ] Distance capped at 255 (uint8 max)
- [ ] Computed after initial terrain generation completes
- [ ] Recomputed if water bodies change (sea level change, terraforming)
- [ ] get_water_distance(x, y) returns O(1) pre-computed value
- [ ] Memory: 1 byte per tile (256KB at 512x512)
- [ ] Performance: BFS completes in <5ms for 512x512
- [ ] Unit tests with known water configurations and expected distances

**Dependencies:**
- Blocked by: 3-002 (TerrainGrid for spatial data)
- Blocks: 3-016 (query API uses this data)

**Agent Notes:**
- Systems Architect: This is a critical optimization. Without it, every FluidSystem, LandValueSystem, and PortSystem query would need spatial search. BFS is O(width * height) = O(262K) for 512x512, ~1-5ms.

---

### Ticket 3-007: Seeded RNG and Noise Infrastructure

**Type:** infrastructure
**System:** TerrainSystem
**Group:** A
**Estimated Scope:** M
**Status:** NEW

**Description:**
Implement deterministic random number generation and noise functions for procedural terrain. Seeded PRNG (xoshiro256** or similar) with uint64 seed. Simplex or Perlin noise implementation that is cross-platform deterministic. Fractal Brownian motion (fBm) for multi-octave noise. All generation must produce identical results across Windows, macOS, and Linux for multiplayer correctness.

**Acceptance Criteria:**
- [ ] Deterministic PRNG seeded from uint64 map_seed (NOT std::rand or platform RNG)
- [ ] Simplex or Perlin noise function producing identical results across platforms
- [ ] fBm (fractal Brownian motion) with configurable octaves, lacunarity, persistence
- [ ] Integer-based or strict floating-point noise to avoid cross-platform divergence
- [ ] Compiled with strict FP semantics (/fp:strict on MSVC, -ffp-contract=off on GCC/Clang)
- [ ] No threading in generation (single-threaded for deterministic RNG call order)
- [ ] Cross-platform verification test: same seed produces identical noise output on all platforms
- [ ] Golden output reference for CI testing (known seed -> known output binary comparison)

**Dependencies:**
- Blocked by: 3-002 (TerrainGrid to write into)
- Blocks: 3-008, 3-009, 3-010, 3-011, 3-012

**Agent Notes:**
- Systems Architect: HIGH RISK. Cross-platform FP determinism is the single most critical multiplayer requirement. Mitigation: integer-based noise, strict FP flags, golden output tests. Fallback: server-only generation with full grid transfer (1MB compressed).
- Game Designer: Determinism enables seed sharing for replayable maps and tournament play.

---

### Group B: Procedural Generation

---

### Ticket 3-008: Elevation Heightmap Generation

**Type:** feature
**System:** TerrainSystem
**Group:** B
**Estimated Scope:** L
**Status:** NEW

**Description:**
Generate the elevation heightmap using multi-octave noise. Create geologically coherent terrain: ridges (hills/mountains), valleys, plateaus, and lowlands. Output elevation values 0-31 for every tile. Must feel intentional, not random -- ridgelines, saddle points, and valleys should be recognizable features. Assign Ridge terrain type to tiles above configurable thresholds.

**Acceptance Criteria:**
- [ ] Multi-octave noise (4-6 octaves) generates elevation heightmap
- [ ] Configurable parameters: roughness, amplitude, feature scale, ridge threshold
- [ ] Elevation values 0-31 for every tile
- [ ] Ridges form geologically coherent ridgelines and plateaus (not random noise hills)
- [ ] Valleys form naturally between ridges
- [ ] Tiles above ridge threshold assigned TerrainType::Ridge
- [ ] Remaining non-water tiles default to TerrainType::Substrate
- [ ] Generation is fully deterministic (same seed = same heightmap)
- [ ] Row-major generation order (top-to-bottom, left-to-right)
- [ ] Performance: <50ms for 512x512

**Dependencies:**
- Blocked by: 3-007 (noise infrastructure), 3-002 (TerrainGrid)
- Blocks: 3-009, 3-010, 3-012, 3-013

**Agent Notes:**
- Systems Architect: Primary noise cost: ~1.5M evaluations for 512x512 with 6 octaves at ~50ns each = ~75ms. Within budget.
- Game Designer: Ridges should use the full 32-level range. Avoid purely random noise -- terrain should feel geological. Elevation bands: lowlands (0-3), foothills (4-10), highlands (11-20), ridgelines (21-27), peaks (28-31).

---

### Ticket 3-009: Water Body Generation (Deep Void, Flow Channels, Still Basins)

**Type:** feature
**System:** TerrainSystem
**Group:** B
**Estimated Scope:** XL
**Status:** NEW

**Description:**
Place all three water terrain types using the elevation heightmap. Deep Void (ocean) along map edges using sea level threshold. Flow Channels (rivers) from high elevation to ocean/map-edge via gradient descent. Still Basins (lakes) in terrain depressions. Assign water body IDs and flow directions. Update derived data (coastal flags, underwater flags, water distance field) after placement.

**Acceptance Criteria:**
- [ ] DeepVoid placed along map edges: tiles below sea_level within configurable border width
- [ ] FlowChannels generated from high-elevation source points to ocean/edge via gradient descent
- [ ] At least one river per map guaranteed (validation in ticket 3-013)
- [ ] Branching tributaries where terrain supports them
- [ ] StillBasins placed in terrain depressions (areas surrounded by higher terrain below sea level or via deliberate depression filling)
- [ ] Water body IDs assigned via flood-fill (ticket 3-005 storage)
- [ ] Flow direction per river tile computed from elevation gradient
- [ ] is_underwater flag set for all water tiles
- [ ] is_coastal flag set for land tiles adjacent to water
- [ ] Water distance field computed after placement (ticket 3-006)
- [ ] Water types total ~15-20% of map area
- [ ] Fully deterministic generation

**Dependencies:**
- Blocked by: 3-008 (elevation heightmap), 3-005 (water body storage), 3-007 (noise/RNG), 3-002 (TerrainGrid)
- Blocks: 3-010, 3-013, 3-027

**Agent Notes:**
- Systems Architect: MEDIUM RISK. Convincing river generation is notoriously difficult. Use well-known algorithms: gradient descent for rivers, depression filling for lakes. Coastline via elevation threshold.
- Game Designer: Flow channels are the single most gameplay-defining terrain feature. They must flow purposefully from high to low. A map with a single major flow channel bisecting the center creates dramatically different dynamics than branching networks. Not every map needs deep void (landlocked maps valid).

---

### Ticket 3-010: Alien Biome Distribution

**Type:** feature
**System:** TerrainSystem
**Group:** B
**Estimated Scope:** L
**Status:** NEW

**Description:**
Place the four alien terrain types and biolume groves using noise-based distribution with ecological rules. Biomes form coherent clusters, not random scatter. Placement respects geographic logic: BiolumeGroves in lowlands and along flow channel banks, PrismaFields on exposed ridgelines and plateaus, SporeFlats in transitional zones, BlightMires in lowlands (toxic runoff), EmberCrust at high elevation (volcanic ridges).

**Acceptance Criteria:**
- [ ] BiolumeGrove placed as clusters in lowlands and along flow channel banks (~8-12% of map)
- [ ] PrismaFields placed as rare clusters on ridgelines and plateaus (~2-4% of map)
- [ ] SporeFlats placed in transitional zones between substrate and groves (~3-5% of map)
- [ ] BlightMires placed in lowlands, never blocking all expansion paths (~3-5% of map)
- [ ] EmberCrust placed at high elevation in volcanic ridge patterns (~3-6% of map)
- [ ] Substrate remains as default (~35-45% of map)
- [ ] Biomes form coherent clusters (noise-based with proximity rules), not single-tile scatter
- [ ] Placement uses elevation-dependent and proximity-dependent rules
- [ ] Every map has at least one blight mire patch affecting expansion
- [ ] PrismaFields are the rarest special terrain -- visible from far zoom as landmarks
- [ ] Fully deterministic generation

**Dependencies:**
- Blocked by: 3-008 (elevation heightmap), 3-007 (noise/RNG), 3-001 (TerrainType enum)
- Blocks: 3-013

**Agent Notes:**
- Systems Architect: Biome distribution uses separate noise channels for each biome, masked by elevation and proximity rules. Single-threaded, deterministic.
- Game Designer: Rarity creates strategic value. Prisma fields rarest and most visually distinctive. Blight mires should be speed bumps, not brick walls. Biome coherence is critical -- "crystals grow high, toxins pool low" should be intuitive to players.

---

### Ticket 3-011: Generation Parameter Scaling Across Map Sizes

**Type:** task
**System:** TerrainSystem
**Group:** B
**Estimated Scope:** M
**Status:** NEW

**Description:**
Ensure procedural generation parameters scale properly across 128/256/512 map sizes. Feature density should remain perceptually similar regardless of map size. A 512x512 map should have proportionally more features (more rivers, more biome clusters), not just be a zoomed-in 256x256. Noise frequency, biome cluster size, and feature count must scale with map dimensions.

**Acceptance Criteria:**
- [ ] Noise frequency scales inversely with map size (features have consistent world-space scale)
- [ ] Feature count scales proportionally (512x512 has ~4x the features of 256x256)
- [ ] Biome cluster minimum size scales with map size
- [ ] River count and length scale with map dimensions
- [ ] Water body count and size proportional to map area
- [ ] Generation parameters documented in a scaling table
- [ ] Visual comparison screenshots at all three sizes showing perceptual consistency
- [ ] All three sizes pass map validation (ticket 3-013)

**Dependencies:**
- Blocked by: 3-008, 3-009, 3-010 (generation passes to scale)
- Blocks: None (tuning pass, non-blocking)

**Agent Notes:**
- Game Designer: 128x128 should feel intimate with few dramatic features. 256x256 is the balanced default. 512x512 should feel expansive with multiple "regions" of distinct character.

---

### Ticket 3-012: Multiplayer Spawn Point Selection and Fairness

**Type:** feature
**System:** TerrainSystem
**Group:** B
**Estimated Scope:** L
**Status:** NEW

**Description:**
Implement spawn point selection with terrain value scoring to ensure multiplayer fairness. Spawn points must meet placement rules (on substrate, minimum buildable radius, not near blight mires, access to fluid). For 2-4 player maps, generate approximately equal-value spawn locations using terrain value scoring. Support approximate rotational symmetry for competitive play.

**Acceptance Criteria:**
- [ ] Spawn points placed on or adjacent to substrate with minimum buildable radius
- [ ] No spawn within contamination radius of blight mires
- [ ] Each spawn region has access to at least one fluid source within configurable distance
- [ ] Spawn points roughly equidistant from each other
- [ ] Terrain value score computed per potential spawn: fluid access, special terrain, buildable area, contamination exposure, elevation advantage
- [ ] All spawn scores within 15% tolerance of each other
- [ ] Approximate rotational symmetry: 180 deg for 2 players, 120 deg for 3, 90 deg for 4
- [ ] Symmetry applied to major features (rivers, ridges, biome distribution), not pixel-perfect
- [ ] Spawn positions stored with map data for multiplayer join
- [ ] Deterministic spawn selection from seed

**Dependencies:**
- Blocked by: 3-008, 3-009, 3-010 (complete terrain generation)
- Blocks: 3-013 (validation checks spawn quality)

**Agent Notes:**
- Systems Architect: Spawn selection runs after all generation passes complete. Server-authoritative.
- Game Designer: Target is approximately equal opportunity, not identical starting conditions. Different advantages (fluid vs. value vs. energy) are valid as long as no single advantage is strictly dominant. Players should be able to describe their starting terrain: "I got the river bank" or "I got the crystal plateau."

---

### Ticket 3-013: Post-Generation Map Validation

**Type:** feature
**System:** TerrainSystem
**Group:** B
**Estimated Scope:** M
**Status:** NEW

**Description:**
Validate generated maps meet quality requirements before accepting them. Check minimum buildable area, water body connectivity, terrain type distribution, river existence, coastline continuity, and spawn point quality. If validation fails, regenerate with a different seed increment (not infinite loop -- cap at N retries then accept with warning).

**Acceptance Criteria:**
- [ ] Minimum buildable area percentage enforced (>= 50% immediately buildable)
- [ ] At least one river (flow channel) exists
- [ ] Coastline (if deep void present) is continuous (no single-tile ocean gaps)
- [ ] No single-tile terrain type anomalies (isolated single tiles of a type surrounded by different type)
- [ ] Terrain type distribution within target ranges (substrate 35-45%, etc.)
- [ ] All spawn points meet minimum quality threshold (ticket 3-012)
- [ ] Validation completes in <10ms
- [ ] Retry with seed+1 on failure, up to 10 retries
- [ ] Warning logged if all retries exhausted (accept best attempt)
- [ ] Unit tests with known-bad terrain configurations

**Dependencies:**
- Blocked by: 3-008, 3-009, 3-010, 3-012 (all generation passes and spawn selection)
- Blocks: None (final generation step)

**Agent Notes:**
- Systems Architect: Validation is a safety net, not a design tool. Good generation parameters should rarely trigger validation failures.
- Game Designer: A map that fails validation creates a bad first impression. Better to regenerate silently than present a broken map.

---

### Group C: Query API and Interfaces

---

### Ticket 3-014: ITerrainQueryable Interface Definition

**Type:** infrastructure
**System:** Cross-System
**Group:** C
**Estimated Scope:** M
**Status:** NEW

**Description:**
Define and implement the ITerrainQueryable interface -- the primary way all downstream systems (ZoneSystem, EnergySystem, FluidSystem, TransportSystem, PortSystem, LandValueSystem) interact with terrain. All queries must be O(1) or use pre-computed data. Interface stability is paramount: this API will be called by at least 6 major systems.

**Acceptance Criteria:**
- [ ] ITerrainQueryable abstract interface defined with all methods:
  - get_terrain_type(x, y) -> TerrainType
  - get_elevation(x, y) -> uint8
  - is_buildable(x, y) -> bool
  - get_slope(x1, y1, x2, y2) -> uint8
  - get_water_distance(x, y) -> uint32
  - get_average_elevation(x, y, radius) -> float
  - get_value_bonus(x, y) -> float
  - get_harmony_bonus(x, y) -> float
  - get_build_cost_modifier(x, y) -> int32
  - get_contamination_output(x, y) -> uint32
  - get_map_width() -> uint32
  - get_map_height() -> uint32
  - get_sea_level() -> uint8
- [ ] Buildability logic: type.buildable OR (type.clearable AND is_cleared) AND NOT is_underwater
- [ ] Out-of-bounds coordinates return safe defaults (not UB)
- [ ] All O(1) queries verified with benchmarks
- [ ] Interface registered in interfaces.yaml
- [ ] TerrainSystem implements ITerrainQueryable

**Dependencies:**
- Blocked by: 3-001 (TerrainType), 3-002 (TerrainGrid), 3-003 (TerrainTypeInfo)
- Blocks: 3-015, 3-016

**Agent Notes:**
- Systems Architect: Interface stability is paramount. Lock this down during Epic 3. Changes after downstream systems are built would be extremely costly. Reserve bits in TerrainComponent flags for future extensibility.

---

### Ticket 3-015: ITerrainQueryable Batch Query Support

**Type:** feature
**System:** Cross-System
**Group:** C
**Estimated Scope:** S
**Status:** NEW

**Description:**
Add batch query methods to ITerrainQueryable for systems that need data for many tiles at once. Used by ZoneSystem for area operations and by simulation overlay generation. Batch queries iterate rectangular sub-regions efficiently.

**Acceptance Criteria:**
- [ ] get_tiles_in_rect(GridRect, out vector<TerrainComponent>) fills output vector
- [ ] get_buildable_tiles_in_rect(GridRect) returns count of buildable tiles
- [ ] count_terrain_type_in_rect(GridRect, TerrainType) returns count of matching tiles
- [ ] Batch queries iterate row-major for cache efficiency
- [ ] Performance: 10,000 tile rect query < 10 microseconds
- [ ] Unit tests with various rect sizes and positions including edge-of-map rects

**Dependencies:**
- Blocked by: 3-014 (ITerrainQueryable interface)
- Blocks: None

**Agent Notes:**
- Systems Architect: Batch queries prevent systems from making 10,000 individual O(1) calls with function overhead. Row-major iteration of sub-rects is cache-friendly.

---

### Ticket 3-016: ITerrainRenderData Interface for Rendering

**Type:** infrastructure
**System:** Cross-System
**Group:** C
**Estimated Scope:** M
**Status:** NEW

**Description:**
Define and implement the ITerrainRenderData interface for RenderingSystem to efficiently access terrain data for mesh generation. Provides const reference to the full TerrainGrid, TerrainTypeInfo lookup, dirty chunk tracking, water body queries, and flow direction queries. This is the data contract between TerrainSystem and the terrain rendering subsystem.

**Acceptance Criteria:**
- [ ] ITerrainRenderData interface defined with methods:
  - get_grid() -> const TerrainGrid&
  - get_type_info(TerrainType) -> const TerrainTypeInfo&
  - is_chunk_dirty(chunk_x, chunk_y) -> bool
  - clear_chunk_dirty(chunk_x, chunk_y) -> void
  - get_chunk_size() -> uint32 (returns 32)
  - get_water_body_id(x, y) -> uint16
  - get_flow_direction(x, y) -> FlowDirection
- [ ] TerrainSystem implements ITerrainRenderData
- [ ] Const-correctness enforced: rendering cannot modify terrain data
- [ ] Interface registered in interfaces.yaml
- [ ] Integration test: RenderingSystem can read terrain data through interface

**Dependencies:**
- Blocked by: 3-002 (TerrainGrid), 3-003 (TerrainTypeInfo), 3-004 (dirty flags), 3-006 (water distance)
- Blocks: 3-025, 3-027, 3-029, 3-031

**Agent Notes:**
- Systems Architect: This interface is read-only for rendering. TerrainSystem is the sole writer.
- Graphics Engineer: Rendering copies 32x32 chunk data (~4KB) to a local buffer during mesh rebuild. Direct grid reference avoids unnecessary copies for read-only access.

---

### Ticket 3-017: ITerrainModifier Interface

**Type:** infrastructure
**System:** Cross-System
**Group:** C
**Estimated Scope:** S
**Status:** NEW

**Description:**
Define the ITerrainModifier interface for terrain modification operations. Separate from ITerrainQueryable because modifications are only available server-side in multiplayer. Includes cost query methods that can be called client-side for UI preview.

**Acceptance Criteria:**
- [ ] ITerrainModifier interface defined with methods:
  - clear_terrain(x, y, player_id) -> bool (success/fail)
  - level_terrain(x, y, target_elevation, player_id) -> bool
  - get_clear_cost(x, y) -> int64
  - get_level_cost(x, y, target_elevation) -> int64
- [ ] Modification methods validate preconditions (correct terrain type, within bounds)
- [ ] Cost query methods are const (safe for client-side preview)
- [ ] Interface registered in interfaces.yaml
- [ ] TerrainSystem implements ITerrainModifier

**Dependencies:**
- Blocked by: 3-002 (TerrainGrid for data access)
- Blocks: 3-019, 3-020, 3-021

**Agent Notes:**
- Systems Architect: Modifications are server-authoritative. Client sends requests; server validates and applies.
- Game Designer: Cost queries available client-side for UI preview (show cost before committing).

---

### Group D: Terrain Modification

---

### Ticket 3-018: Terrain Contamination Source Queries

**Type:** feature
**System:** TerrainSystem
**Group:** D
**Estimated Scope:** S
**Status:** NEW

**Description:**
Expose terrain-based contamination sources for the ContaminationSystem (Epic 10). BlightMires tiles generate contamination per tick. Since terrain tiles are not individual entities, expose via a bulk query that returns all contamination-producing tile positions and their output rates.

**Acceptance Criteria:**
- [ ] get_terrain_contamination_sources() returns vector of {position, contamination_per_tick, type}
- [ ] Only BlightMires tiles produce contamination
- [ ] Output rate from TerrainTypeInfo static table
- [ ] Result cached and invalidated when terrain is modified (blight mire terraformed away)
- [ ] Performance: query returns cached data in O(1); cache rebuild in O(blight_mire_count)

**Dependencies:**
- Blocked by: 3-002 (TerrainGrid), 3-003 (TerrainTypeInfo)
- Blocks: None (consumed by Epic 10)

**Agent Notes:**
- Systems Architect: Terrain tiles are not entities, so ContaminationSystem cannot use a per-entity component query. This bulk query pattern is appropriate.
- Game Designer: Blight mires generate contamination in a radius, reducing sector value nearby. This is a passive, ongoing effect.

---

### Ticket 3-019: Purge Terrain Operation (Instant Clear)

**Type:** feature
**System:** TerrainSystem
**Group:** D
**Estimated Scope:** M
**Status:** NEW

**Description:**
Implement the purge_terrain operation to clear vegetation (BiolumeGrove) and crystals (PrismaFields) from a tile. Purge is instant (one tick). Sets is_cleared flag. PrismaFields clearing yields one-time credit revenue. Fires TerrainModifiedEvent. Server-authoritative with validation.

**Acceptance Criteria:**
- [ ] clear_terrain(x, y, player_id) validates: tile is clearable type (BiolumeGrove, PrismaFields, SporeFlats), not already cleared, player has authority
- [ ] Sets is_cleared flag bit on success
- [ ] Returns clear cost from TerrainTypeInfo (negative for PrismaFields = revenue)
- [ ] Fires TerrainModifiedEvent with ModificationType::Cleared
- [ ] Marks affected chunk(s) dirty for rendering rebuild
- [ ] Cleared BiolumeGrove/SporeFlats tiles become buildable substrate visually
- [ ] Operation is instant (single tick)
- [ ] Unit tests for each clearable terrain type and rejection of non-clearable types

**Dependencies:**
- Blocked by: 3-017 (ITerrainModifier), 3-004 (TerrainModifiedEvent)
- Blocks: 3-031 (visual update on clear)

**Agent Notes:**
- Systems Architect: Server validates ownership and cost. Client sends TerrainModifyRequest message.
- Game Designer: Purging should feel like a sacrifice. Biolume groves are the most visually striking natural terrain -- purging removes beauty for utility. PrismaFields give one-time credits on clear, creating a "clear now vs. preserve for ongoing value" dilemma.

---

### Ticket 3-020: Grade Terrain Operation (Multi-Tick Leveling)

**Type:** feature
**System:** TerrainSystem
**Group:** D
**Estimated Scope:** L
**Status:** NEW

**Description:**
Implement the grade_terrain operation to raise or lower tile elevation. Multi-tick operation: larger elevation changes take more ticks. Creates a temporary entity with TerrainModificationComponent tracking progress. Cost scales with elevation delta. Cannot modify water tiles. Cannot exceed elevation bounds (0-31). Server-authoritative with per-tick validation.

**Acceptance Criteria:**
- [ ] level_terrain(x, y, target_elevation, player_id) validates: not water type, target in 0-31, player has authority
- [ ] Cost = base_cost * abs(current_elevation - target_elevation) from configurable table
- [ ] Creates temporary entity with TerrainModificationComponent tracking progress (ticks remaining)
- [ ] Each tick applies one elevation level change until target reached
- [ ] Fires TerrainModifiedEvent each tick as elevation changes
- [ ] Adjacent tiles may have is_slope flag recalculated
- [ ] Marks affected chunk dirty each tick during modification
- [ ] Cancel support: player can abort in-progress grading (partial result stays)
- [ ] Unit tests for single-level and multi-level grading, rejection of water tiles

**Dependencies:**
- Blocked by: 3-017 (ITerrainModifier), 3-004 (TerrainModifiedEvent)
- Blocks: 3-031 (visual update on grade)

**Agent Notes:**
- Systems Architect: Multi-tick operations use a TerrainModificationComponent on a temporary entity, validated server-side each tick. Aligns with game designer's pacing: grading is a mid-game investment.
- Game Designer: Grading should feel powerful -- reshaping the land is an act of mastery. The gradual transformation (not instant) gives engineering accomplishment.

---

### Ticket 3-021: Terraform Operation (Multi-Tick Type Conversion)

**Type:** feature
**System:** TerrainSystem
**Group:** D
**Estimated Scope:** L
**Status:** NEW

**Description:**
Implement terraform operation to convert one terrain type to another (e.g., BlightMires to Substrate, EmberCrust to Substrate). Very expensive, multi-tick, late-game operation. Removes both negative effects (contamination) and positive effects (geothermal bonus). Server-authoritative.

**Acceptance Criteria:**
- [ ] terraform_terrain(x, y, target_type, player_id) validates: source type is terraformable, player has authority, cost payable
- [ ] BlightMires -> Substrate: removes contamination source, very high cost, long duration
- [ ] EmberCrust -> Substrate: removes geothermal bonus and build cost modifier, high cost
- [ ] Multi-tick duration: configurable ticks per terrain type conversion (BlightMires longest)
- [ ] Fires TerrainModifiedEvent on completion
- [ ] Contamination source cache updated if blight mire removed
- [ ] Water distance field NOT recomputed (water tiles cannot be terraformed)
- [ ] Cancel support with partial refund
- [ ] Unit tests for each terraformable conversion and rejection of non-terraformable types

**Dependencies:**
- Blocked by: 3-017 (ITerrainModifier), 3-004 (TerrainModifiedEvent), 3-019 (purge as simpler baseline)
- Blocks: None

**Agent Notes:**
- Systems Architect: Terraform extends the modification pattern from purge (instant) and grade (multi-tick) to type conversion (multi-tick, very long).
- Game Designer: Blight mire reclamation is a late-game achievement. The sickly glow being replaced by clean substrate should feel like the land is healed. Cost should scale with colony wealth -- always a significant investment, never trivial.

---

### Ticket 3-022: Terrain Modification Authority and Network Messages

**Type:** feature
**System:** Cross-System
**Group:** D
**Estimated Scope:** M
**Status:** NEW

**Description:**
Implement the server-authoritative validation pipeline for terrain modifications. Client sends TerrainModifyRequest message. Server validates ownership, cost, terrain type. Server applies change and broadcasts TerrainModifiedEvent to all clients. All clients update local TerrainGrid and rebuild affected render chunks. Integrates with Epic 1 SyncSystem.

**Acceptance Criteria:**
- [ ] TerrainModifyRequest message type: position, modification_type (purge/grade/terraform), target params
- [ ] Server validates: tile in bounds, player has authority over tile, terrain type allows modification, cost affordable (future EconomySystem integration point)
- [ ] Server applies modification to authoritative TerrainGrid
- [ ] Server broadcasts TerrainModifiedEvent to all connected clients
- [ ] Clients apply modification to local TerrainGrid on receiving event
- [ ] Conflict resolution: server processes in order received, tile ownership prevents conflicts
- [ ] Integration with Epic 1 ISerializable for message format
- [ ] Unit tests for validation rejection cases (wrong type, out of bounds, no authority)

**Dependencies:**
- Blocked by: 3-019, 3-020 (modification operations to validate)
- Blocks: None

**Agent Notes:**
- Systems Architect: Terrain modifications are rare events (not per-tick). On-change sync only. Server is authoritative. No conflict possible since tiles are independently owned.

---

### Group E: Terrain Mesh Rendering

---

### Ticket 3-023: Terrain Vertex Format and Chunk Data Structure

**Type:** infrastructure
**System:** RenderingSystem
**Group:** E
**Estimated Scope:** M
**Status:** NEW

**Description:**
Define the terrain vertex format and chunk mesh data structure. Each terrain vertex carries position (world-space), normal (computed from adjacent elevations), UV coordinates, tile coordinate, and terrain_type. Chunk mesh structure holds vertex buffer, index buffer, AABB, and dirty state. 32x32 tile chunks with shared corner vertices (33x33 = 1,089 vertices per chunk).

**Acceptance Criteria:**
- [ ] TerrainVertex struct: float3 position, float3 normal, float2 texcoord, float2 tile_coord, uint32 terrain_type
- [ ] TerrainChunkMesh struct: GPU vertex buffer handle, GPU index buffer handle, AABB bounding box, vertex count, index count
- [ ] 32x32 tiles per chunk = 33x33 shared corner vertices = 1,089 base vertices
- [ ] Index buffer: 32x32 * 2 triangles * 3 indices = 6,144 base indices
- [ ] AABB computed from chunk world bounds + max elevation in chunk
- [ ] Memory per chunk: ~40 bytes * 1,089 vertices = ~44KB vertex data + ~24KB index data
- [ ] Struct size validated against Epic 2 GPU memory budget (17-66 MB total terrain)

**Dependencies:**
- Blocked by: Epic 2 tickets 2-003 (GPU resources), 2-010 (GPU mesh representation)
- Blocks: 3-024, 3-025, 3-026

**Agent Notes:**
- Graphics Engineer: Per-vertex terrain_type enables the fragment shader to select correct visual treatment per tile. Hard edges at type boundaries fit the toon aesthetic. No texture splatting needed.

---

### Ticket 3-024: Terrain Normal Calculation

**Type:** feature
**System:** RenderingSystem
**Group:** E
**Estimated Scope:** S
**Status:** NEW

**Description:**
Compute terrain normals from the heightmap using central differences. Normals drive toon shader lighting bands: flat terrain gets full light, slopes shift toward shadow, cliff faces render in deep shadow. This makes elevation automatically readable through lighting without special effort.

**Acceptance Criteria:**
- [ ] Normal computed per vertex from adjacent elevation values using central differences
- [ ] Formula: nx = height(x-1,z) - height(x+1,z), nz = height(x,z-1) - height(x,z+1), ny = 2.0 * ELEVATION_HEIGHT, normalize
- [ ] Chunk edge normals use neighbor chunk elevation data (no seams at chunk boundaries)
- [ ] Map edge normals handle boundary gracefully (mirror or clamp neighbor lookups)
- [ ] Normals produce correct toon shader banding: flat = bright, slope = mid, steep = shadow
- [ ] Unit test: flat terrain produces normals pointing straight up (0, 1, 0)
- [ ] Unit test: sloped terrain produces correctly oriented normals

**Dependencies:**
- Blocked by: 3-023 (vertex format)
- Blocks: 3-025, 3-026

**Agent Notes:**
- Graphics Engineer: Central difference normals produce smooth shading across elevation gradients. At chunk edges, must read neighbor chunk elevations to avoid normal seams. This is trivial -- just read from TerrainGrid which has the full map.

---

### Ticket 3-025: Terrain Chunk Mesh Generator

**Type:** feature
**System:** RenderingSystem
**Group:** E
**Estimated Scope:** XL
**Status:** NEW

**Description:**
Build the terrain chunk mesh generator that converts TerrainGrid data into GPU-ready vertex/index buffers for each 32x32 chunk. Reads data via ITerrainRenderData interface. Generates shared-corner vertices with position, normal, UV, tile_coord, terrain_type. Handles cliff face geometry for steep elevation transitions. Supports incremental rebuild of dirty chunks via staged GPU buffer upload.

**Acceptance Criteria:**
- [ ] Generates complete mesh for a 32x32 chunk from TerrainGrid data
- [ ] Vertex positions: x = tile_x, y = elevation * 0.25 (ELEVATION_HEIGHT from Epic 2 ticket 2-033), z = tile_z
- [ ] Normals computed per central differences (ticket 3-024)
- [ ] Per-vertex terrain_type set from TerrainGrid data
- [ ] Cliff face geometry generated when elevation delta between adjacent tiles > configurable threshold (default: 2 levels)
- [ ] Cliff face normals oriented horizontally for distinct toon shader shadow bands
- [ ] Vertex and index buffers uploaded to GPU via SDL_UploadToGPUBuffer
- [ ] Chunk AABB computed and stored for frustum culling
- [ ] Incremental rebuild: only regenerate dirty chunks (ticket 3-004 dirty flags)
- [ ] At most 1 chunk rebuilt per frame to avoid GPU stalls (queue remaining)
- [ ] Full map initial build: all chunks generated during loading
- [ ] Performance: single chunk rebuild < 1ms

**Dependencies:**
- Blocked by: 3-023 (vertex format), 3-024 (normals), 3-016 (ITerrainRenderData), 3-003 (TerrainTypeInfo), 3-004 (dirty flags)
- Blocks: 3-031, 3-033, 3-034

**Agent Notes:**
- Graphics Engineer: This is the core terrain rendering work item. One draw call per visible chunk regardless of terrain type mix. Cliff faces create strong visual contrast in toon shading. Staged GPU upload avoids stalls.
- Systems Architect: Chunk size 32x32 aligns with Epic 2 spatial partitioning (ticket 2-050). Rendering copies chunk-local data (~4KB) from row-major TerrainGrid during rebuild.

---

### Ticket 3-026: Terrain Fragment Shader Variant

**Type:** feature
**System:** RenderingSystem
**Group:** E
**Estimated Scope:** L
**Status:** NEW

**Description:**
Extend the base toon shader (Epic 2 ticket 2-005) with a terrain-specific fragment shader variant. Reads terrain_type per vertex and indexes into a 10-entry uniform buffer palette for base color and emissive color/intensity. Implements animated glow behaviors per terrain type (static, pulse, shimmer, irregular). Adds emissive term unaffected by lighting. Outputs to both color and emissive targets for bloom extraction.

**Acceptance Criteria:**
- [ ] cbuffer TerrainVisuals with base_colors[10], emissive_colors[10] (rgb + intensity in alpha), glow_time, sea_level
- [ ] Fragment shader reads terrain_type from vertex input, indexes into palette
- [ ] Toon lighting applied to base color (3-4 bands)
- [ ] Emissive added to final output, unaffected by lighting bands
- [ ] Animated glow behaviors implemented per terrain type:
  - Substrate/Ridge: static
  - Water types: slow pulse (6-8s period)
  - BiolumeGrove: subtle pulse (4s)
  - PrismaFields: shimmer (random flicker)
  - SporeFlats: rhythmic pulse (3s)
  - BlightMires: irregular bubble pulse
  - EmberCrust: slow throb (5s)
- [ ] Normal-based crevice glow for Ridge and EmberCrust (glow increases where normal deviates from vertical)
- [ ] Output to emissive render target for bloom extraction (if MRT used, per ticket 2-007)
- [ ] Shader compiles on all target platforms (SPIR-V, DXIL)
- [ ] Performance: terrain fragment shading adds negligible cost (palette lookup cheaper than texture sample)

**Dependencies:**
- Blocked by: 3-023 (vertex format with terrain_type), Epic 2 tickets 2-005 (toon shader), 2-037 (emissive support), 2-004 (shader pipeline)
- Blocks: 3-031

**Agent Notes:**
- Graphics Engineer: The 10-entry uniform buffer palette is trivial GPU cost. Glow behaviors use time uniform + simple math. Spatial coherence of terrain types means minimal shader branch divergence within a chunk. No per-tile textures needed -- flat color + glow is cheaper and fits toon aesthetic.

---

### Group F: Water Rendering

---

### Ticket 3-027: Water Surface Mesh Generation

**Type:** feature
**System:** RenderingSystem
**Group:** F
**Estimated Scope:** L
**Status:** NEW

**Description:**
Generate separate water surface meshes for each water body (ocean, rivers, lakes). Water mesh is NOT part of terrain chunks -- it is a separate semi-transparent layer rendered after terrain. Flat plane at sea_level elevation (or per-body elevation for lakes). Per-vertex shore_factor attribute for shoreline glow. One mesh per water body for efficient draw calls.

**Acceptance Criteria:**
- [ ] Separate mesh per water body (using body IDs from ticket 3-005)
- [ ] Water surface at sea_level elevation (Y = sea_level * ELEVATION_HEIGHT)
- [ ] Per-vertex shore_factor (0.0-1.0): 1.0 at land-adjacent vertices, 0.0 at interior
- [ ] Ocean: single mesh covering all DeepVoid tiles at map edges
- [ ] Rivers: mesh per river body following FlowChannel tiles
- [ ] Lakes: mesh per StillBasin body
- [ ] Water mesh vertices at tile corners (shared with terrain grid but separate buffer)
- [ ] Index buffer generates quads only for water tiles within each body
- [ ] Estimated draw calls: 5-15 for all water on map
- [ ] Water mesh rebuilt when sea level changes or terrain modified near water

**Dependencies:**
- Blocked by: 3-005 (water body IDs), 3-016 (ITerrainRenderData), 3-009 (water generation)
- Blocks: 3-028, 3-029

**Agent Notes:**
- Graphics Engineer: Separate water mesh enables semi-transparency, animated UV scrolling, and per-vertex shoreline glow without affecting terrain chunk rendering. Terrain mesh beneath water still renders (visible through alpha as dark depth).

---

### Ticket 3-028: Water Fragment Shader and Rendering

**Type:** feature
**System:** RenderingSystem
**Group:** F
**Estimated Scope:** L
**Status:** NEW

**Description:**
Implement the water shader and rendering pipeline. Semi-transparent (alpha 0.7-0.8), depth test ON, depth write OFF. Scrolling UV animation for rivers (direction from flow_direction data). Sine-wave normal perturbation for subtle surface highlights. Per-vertex shoreline emissive glow. Rendered in WATER render layer (after terrain, before buildings). Toon-stylized -- no realistic water effects (no reflections, no refraction, no caustics).

**Acceptance Criteria:**
- [ ] Water rendered as semi-transparent: alpha 0.7-0.8
- [ ] Depth test ON, depth write OFF (terrain beneath visible through alpha)
- [ ] Rendered in RenderLayer::WATER (ticket 2-034)
- [ ] Base color: very dark blue/teal (barely visible without glow)
- [ ] Scrolling UV animation for rivers using flow_direction per-tile
- [ ] Gentle UV distortion for ocean and lakes (sine-wave based)
- [ ] Sine-wave normal perturbation for subtle toon-style surface highlights
- [ ] Per-vertex shoreline emissive glow: shore_factor * emissive_color * boost
- [ ] Shoreline glow color matches water type (blue-white for DeepVoid, teal for FlowChannel)
- [ ] Animated emissive: ocean slow pulse (6s), lakes gentle pulse (8s), rivers static (flow handles it)
- [ ] glow_time uniform drives animations
- [ ] No reflections, no refraction, no caustics (toon style)
- [ ] Performance: water adds <1ms to render time

**Dependencies:**
- Blocked by: 3-027 (water mesh), 3-005 (flow direction data), Epic 2 tickets 2-005 (toon shader), 2-016 (transparent handling)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: Dark depth beneath surface glow creates the bioluminescent effect. Shoreline glow is the most visually important water feature -- bright fringe at water-land boundary visible from any zoom. Flow UV scroll direction from TerrainSystem.
- Game Designer: Semi-transparent water reinforces the "deep void" theme. Players see darkness below with surface glow floating on top. Shoreline glow makes coastlines visible from any camera angle.

---

### Group G: Vegetation and Decoration Rendering

---

### Ticket 3-029: Vegetation Instance Placement Generator

**Type:** feature
**System:** RenderingSystem
**Group:** G
**Estimated Scope:** M
**Status:** NEW

**Description:**
Generate deterministic per-tile vegetation/decoration instance placement from tile coordinates. RenderingSystem generates placement (not TerrainSystem) to avoid syncing per-tree positions over the network. Uses seeded PRNG (seed = hash(tile_x, tile_y, map_seed)) for position jitter, Y-axis rotation, and scale variation. BiolumeGrove: 2-4 tree/fungi instances per tile. PrismaFields: 1-3 crystal spire instances per tile. SporeFlats: 4-6 small spore emitter instances per tile.

**Acceptance Criteria:**
- [ ] Deterministic placement from tile coordinate hash (same tile always produces same instances)
- [ ] Position: random jitter within tile bounds, centered on tile
- [ ] Rotation: random Y-axis rotation (0-360 degrees)
- [ ] Scale: random variation 0.8-1.2x base scale
- [ ] BiolumeGrove: 2-4 instances per uncleared forest tile
- [ ] PrismaFields: 1-3 instances per uncleared crystal tile
- [ ] SporeFlats: 4-6 small instances per uncleared spore tile
- [ ] No instances generated for cleared tiles (checks is_cleared flag)
- [ ] Instance data: model matrix (translation + rotation + scale), emissive_color, emissive_intensity
- [ ] All clients produce identical placement from same map_seed (deterministic)
- [ ] Reads tile data via ITerrainRenderData (terrain_type and cleared state)

**Dependencies:**
- Blocked by: 3-016 (ITerrainRenderData for tile type), 3-003 (TerrainTypeInfo for emissive)
- Blocks: 3-030

**Agent Notes:**
- Systems Architect: TerrainSystem provides only tile type and cleared state. Rendering generates placement deterministically from tile coordinate hash. This avoids syncing per-instance data over the network.
- Graphics Engineer: Instance data feeds into Epic 2's GPU instancing system (ticket 2-012).

---

### Ticket 3-030: Vegetation and Decoration Instanced Rendering

**Type:** feature
**System:** RenderingSystem
**Group:** G
**Estimated Scope:** L
**Status:** NEW

**Description:**
Load low-poly glTF vegetation/decoration models and render all instances via GPU instancing. 3-5 tree/fungi model variants for BiolumeGrove, 2-3 crystal spire variants for PrismaFields, small spore emitter models for SporeFlats. Each model variant rendered in a single instanced draw call for ALL visible instances of that variant. Instance buffer carries model matrix, emissive_color, emissive_intensity.

**Acceptance Criteria:**
- [ ] 3-5 low-poly tree/fungi glTF models loaded (50-200 triangles each)
- [ ] 2-3 crystal spire glTF models loaded (200-300 triangles each)
- [ ] Small spore emitter models loaded (30-50 triangles each)
- [ ] All models have emissive material regions (glowing caps, veins, crystal faces)
- [ ] One instanced draw call per model variant for ALL visible instances
- [ ] Total vegetation draw calls: 5-15 (one per model variant)
- [ ] Instance buffer per variant contains: model matrix, emissive_color, emissive_intensity
- [ ] Only instances in LOD 0 chunks rendered (vegetation hidden at LOD 1+)
- [ ] Instance buffer rebuilt each frame with only visible (frustum-culled) instances
- [ ] Triangle budget: 150 avg * 3 per tile * visible forest tiles < 45k triangles typical
- [ ] Performance: vegetation instancing adds < 0.5ms to render time

**Dependencies:**
- Blocked by: 3-029 (placement generator), 3-003 (TerrainTypeInfo for emissive), Epic 2 tickets 2-009 (glTF loading), 2-012 (GPU instancing)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: NOT billboard sprites -- free camera (all viewing angles) makes billboards obvious. Low-poly 3D models with emissive materials. Alien design: bioluminescent mushroom trees, glowing tendrils, crystal-tipped flora. At LOD 1+ distances, individual models are sub-pixel -- hide them and boost terrain emissive instead.
- Game Designer: 1-3 large crystal spires per tile for PrismaFields. Visual impact over density. Crystals should be visible from far zoom as landmarks.

---

### Group H: Performance Integration (LOD, Culling)

---

### Ticket 3-031: Terrain Modification Visual Update Pipeline

**Type:** feature
**System:** RenderingSystem
**Group:** H
**Estimated Scope:** M
**Status:** NEW

**Description:**
When TerrainSystem modifies terrain (purge, grade, terraform), the rendering pipeline must update: rebuild affected chunk mesh, update vegetation instances for affected tiles, interpolate emissive transitions over 0.5s. Handle sea level changes across all water-adjacent chunks. Queue multiple dirty chunks and process at most 1 per frame.

**Acceptance Criteria:**
- [ ] Listen for TerrainModifiedEvent and mark affected chunks dirty
- [ ] Rebuild chunk mesh on next available frame (at most 1 chunk per frame)
- [ ] Queue dirty chunks and process FIFO
- [ ] On purge: remove vegetation instances for cleared tile, begin emissive fade-out (0.5s interpolation from current to 0.0)
- [ ] Optional: emissive "flash" at moment of purge (spike to 1.0 then fade to 0.0)
- [ ] On grade: rebuild chunk with updated elevation vertices and normals
- [ ] On terraform: rebuild chunk with updated terrain_type per-vertex
- [ ] On sea level change: rebuild all water-adjacent chunks, rebuild water meshes
- [ ] Emissive transitions interpolated in instance buffer (smooth visual, not instant swap)
- [ ] Performance: chunk rebuild + upload < 1ms per chunk

**Dependencies:**
- Blocked by: 3-025 (chunk mesh generator), 3-004 (dirty flag system), 3-026 (terrain shader), 3-016 (ITerrainRenderData)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: Rebuild is per-chunk, not whole-map. At most 1 chunk per frame to avoid GPU stalls. Use staged GPU buffer upload. Emissive transition over 0.5s makes purge feel impactful, not just an instant texture swap. Particle effects (floating glow motes) deferred to polish epic.

---

### Ticket 3-032: Terrain LOD Mesh Generation (3 Levels)

**Type:** feature
**System:** RenderingSystem
**Group:** H
**Estimated Scope:** L
**Status:** NEW

**Description:**
Generate terrain mesh at 3 LOD levels per chunk. LOD 0: full 32x32 grid with cliff faces and vegetation. LOD 1: reduced 16x16 grid, no cliff faces, no vegetation (boosted emissive instead). LOD 2: minimal 8x8 grid, flat shaded, terrain appears as colored glow patches. LOD distances configurable per map size. Integrates with Epic 2's LOD framework (ticket 2-049).

**Acceptance Criteria:**
- [ ] LOD 0: 33x33 = 1,089 vertices, cliff faces, vegetation rendered. Default close-range.
- [ ] LOD 1: 17x17 = 289 vertices, smooth interpolation (no cliff faces), no vegetation. ~4x fewer triangles. Emissive boosted for forest/crystal tiles to maintain color impression at distance.
- [ ] LOD 2: 9x9 = 81 vertices, flat shaded. Colored glow patches at extreme distance.
- [ ] LOD distance thresholds configurable: LOD 0->1 at ~80 units, LOD 1->2 at ~160 units
- [ ] Thresholds tuned per map size (LOD 2 may never trigger on 128x128)
- [ ] Each LOD level stored as separate vertex/index buffers per chunk
- [ ] LOD selection based on camera distance to chunk center
- [ ] Integrates with Epic 2 LOD framework (ticket 2-049)
- [ ] GPU memory for all LOD levels: still within terrain's 17-66 MB budget

**Dependencies:**
- Blocked by: 3-025 (chunk mesh generator as LOD 0 baseline), Epic 2 ticket 2-049 (LOD framework)
- Blocks: 3-033

**Agent Notes:**
- Graphics Engineer: LOD 1 drops vegetation and simplifies geometry -- at LOD 1 distances, individual trees are sub-pixel anyway. The glow is the most visible feature at distance. LOD 2 is for 512x512 extreme distance only.

---

### Ticket 3-033: Terrain Chunk LOD Seam Mitigation

**Type:** task
**System:** RenderingSystem
**Group:** H
**Estimated Scope:** M
**Status:** NEW

**Description:**
Adjacent terrain chunks at different LOD levels may have mismatched edge vertices, causing visible seams (gaps or T-junctions). Implement "skirt" geometry: extend each chunk's edge vertices downward by a configurable amount (default 0.5 units) to hide gaps. Skirt geometry is simple and sufficient for toon rendering where small gaps would be hidden by the dark background.

**Acceptance Criteria:**
- [ ] Skirt geometry generated for all chunk edge vertices (4 edges per chunk)
- [ ] Skirt extends downward by configurable amount (default 0.5 world units)
- [ ] Skirt triangles added to chunk index buffer
- [ ] No visible seams between chunks at different LOD levels
- [ ] Skirt vertex count overhead: ~130 extra vertices per chunk edge = ~520 per chunk
- [ ] Skirt does not visibly protrude above terrain surface
- [ ] Visual test at LOD transitions across all three levels

**Dependencies:**
- Blocked by: 3-025 (chunk mesh generator), 3-032 (LOD levels)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: Skirt geometry is the simplest seam mitigation. More complex approaches (LOD transition strips, T-junction stitching) are unnecessary for toon rendering where the dark background hides small imperfections.

---

### Ticket 3-034: Terrain Chunk Frustum Culling Integration

**Type:** feature
**System:** RenderingSystem
**Group:** H
**Estimated Scope:** M
**Status:** NEW

**Description:**
Register terrain chunks with Epic 2's spatial partitioning system (ticket 2-050) and frustum culling (ticket 2-026). Each 32x32 chunk maps to one spatial cell. Chunk AABB includes max elevation for correct culling. Only visible chunks submitted for rendering. At typical zoom: 15-40 visible chunks out of up to 256 on 512x512 maps.

**Acceptance Criteria:**
- [ ] Each terrain chunk registered as a spatial entity in Epic 2's spatial partitioning grid
- [ ] Chunk AABB: min = (chunk_x*32, 0, chunk_z*32), max = (chunk_x*32+32, max_elevation_in_chunk * 0.25, chunk_z*32+32)
- [ ] Frustum culling tests chunk AABBs against camera frustum
- [ ] Only chunks passing frustum test submitted for rendering
- [ ] Culling works correctly at all camera angles (preset and free)
- [ ] No visible popping (conservative culling)
- [ ] Culling statistics available via render stats (ticket 2-042): chunks visible vs total
- [ ] Performance improvement validated on 512x512 maps (84-94% culled at typical zoom)

**Dependencies:**
- Blocked by: 3-025 (chunk mesh with AABB), Epic 2 tickets 2-026 (frustum culling), 2-050 (spatial partitioning)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: Larger maps benefit most from culling. On 512x512, only ~6-15% of terrain chunks visible at any time. This is essential for hitting the draw call budget.

---

### Ticket 3-035: Terrain Edge Detection Tuning

**Type:** task
**System:** RenderingSystem
**Group:** H
**Estimated Scope:** S
**Status:** NEW

**Description:**
Verify and tune Epic 2's edge detection post-process (ticket 2-006) for terrain. Normal-based edges should highlight: terrain type boundaries (where adjacent vertices have different terrain_type), cliff edges (strong normal discontinuity), and water shorelines. Depth-based edges should not produce artifacts at gentle slopes. Accept that same-elevation same-type boundaries may not produce outlines (hard boundaries via color are sufficient).

**Acceptance Criteria:**
- [ ] Cliff edges produce bold outlines (strong normal discontinuity)
- [ ] Water shorelines produce visible outlines
- [ ] Gentle slopes do NOT produce excessive/noisy edge lines
- [ ] Terrain type boundaries between tiles have visual separation via color (edge detection is bonus, not required)
- [ ] Depth linearization correct for perspective projection at terrain distances
- [ ] Edge detection parameters tuned for terrain (may differ from building parameters)
- [ ] Visual test at multiple zoom levels and camera angles

**Dependencies:**
- Blocked by: 3-025 (terrain mesh to test against), Epic 2 ticket 2-006 (edge detection)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: Normal-based edge detection naturally highlights cliff edges and water boundaries. Terrain type boundaries where the surface is geometrically continuous may not produce outlines -- this is acceptable since toon shading with different base colors already provides visual separation.

---

### Group I: Serialization and Multiplayer

---

### Ticket 3-036: Terrain Grid Serialization (Save/Load)

**Type:** feature
**System:** TerrainSystem
**Group:** I
**Estimated Scope:** M
**Status:** NEW

**Description:**
Implement ISerializable for TerrainGrid for save/load (Epic 16) and full snapshot network transfer. Fixed-size types, little-endian, versioned format. Includes terrain tile data, water body IDs, flow directions, sea level, and map seed. For 512x512: ~1MB uncompressed, compresses well due to spatial coherence.

**Acceptance Criteria:**
- [ ] TerrainGrid implements ISerializable with version field
- [ ] Serialization includes: map dimensions, sea_level, map_seed, all tile data, water body IDs, flow directions
- [ ] Fixed-size types (uint8, uint16, uint32) with explicit endianness (little-endian)
- [ ] Deserialization validates version and data integrity
- [ ] Round-trip test: serialize -> deserialize -> binary compare original = result
- [ ] Uncompressed size matches expected: width * height * (4 + 2 + 1) bytes + header
- [ ] Format extensible: version field allows adding new fields without breaking old saves

**Dependencies:**
- Blocked by: 3-002 (TerrainGrid), 3-005 (water body data), Epic 1 (ISerializable interface)
- Blocks: 3-037

**Agent Notes:**
- Systems Architect: For save/load this is the primary format. For network, see ticket 3-037 for the optimized join flow.

---

### Ticket 3-037: Terrain Network Sync (Seed + Modifications)

**Type:** feature
**System:** Cross-System
**Group:** I
**Estimated Scope:** L
**Status:** NEW

**Description:**
Implement the optimized network sync flow for terrain. On player join: server sends map_seed + list of modifications since generation. Client generates terrain locally from seed (deterministic), then applies modifications. During gameplay: server broadcasts TerrainModifiedEvent on each modification. Full snapshot fallback if deterministic verification fails.

**Acceptance Criteria:**
- [ ] Join flow: server sends map_seed (uint64) + ordered list of TerrainModification records
- [ ] Client generates terrain from seed using same generation code (must be deterministic)
- [ ] Client applies modification records in order after generation
- [ ] Verification: client computes checksum of generated terrain, server compares with authoritative checksum
- [ ] If checksum mismatch: fall back to full TerrainGrid snapshot transfer (ticket 3-036)
- [ ] During gameplay: TerrainModifiedEvent broadcast to all clients on each modification
- [ ] Modification record format: position, type, params, timestamp/sequence number
- [ ] Integration with Epic 1 SyncSystem for transport
- [ ] Network bandwidth: seed + modification list << 1MB full grid (typical: < 1KB)

**Dependencies:**
- Blocked by: 3-036 (serialization for fallback), 3-022 (modification authority), 3-007 (deterministic generation)
- Blocks: None

**Agent Notes:**
- Systems Architect: This is a critical optimization. Sending seed + modifications is vastly cheaper than full grid transfer. But it ONLY works if generation is truly deterministic across all platforms. The full snapshot fallback is essential for robustness.

---

### Group J: Visual Polish and Debug

---

### Ticket 3-038: Terrain Debug Visualizations

**Type:** task
**System:** RenderingSystem
**Group:** J
**Estimated Scope:** M
**Status:** NEW

**Description:**
Extend debug grid overlay (Epic 2 ticket 2-040) with terrain-specific debug visualization modes. Essential for development and tuning of generation parameters, LOD distances, and chunk boundaries. All debug modes toggled via debug key bindings.

**Acceptance Criteria:**
- [ ] Elevation heatmap overlay: color ramp from blue (low) to red (high) for 0-31 elevation
- [ ] Terrain type colormap: distinct false color per terrain type for identification
- [ ] Chunk boundary visualization: lines at 32-tile chunk edges
- [ ] LOD level visualization: color per chunk based on current LOD level (green=0, yellow=1, red=2)
- [ ] Normals visualization: per-vertex normal direction arrows (wireframe)
- [ ] Water body ID visualization: unique color per water body
- [ ] Buildability overlay: green for buildable, red for unbuildable tiles
- [ ] All debug modes toggled independently via key bindings
- [ ] Debug overlays render on top of terrain (semi-transparent)
- [ ] Performance: debug overlays add < 0.5ms when active

**Dependencies:**
- Blocked by: 3-025 (terrain mesh to overlay on), Epic 2 ticket 2-040 (debug grid infrastructure)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: These debug views are essential for tuning. Elevation heatmap and terrain type colormap are the most used during development. LOD level visualization helps tune LOD distances.

---

### Ticket 3-039: TerrainVisualConfig Integration with ToonShaderConfig

**Type:** task
**System:** RenderingSystem
**Group:** J
**Estimated Scope:** S
**Status:** NEW

**Description:**
Connect terrain visual configuration data to Epic 2's ToonShaderConfig (ticket 2-008). The 10 terrain type base colors and emissive presets must be accessible as runtime-configurable uniforms. Changes take effect immediately (no restart). Provides the artistic tuning pipeline for terrain visual appearance.

**Acceptance Criteria:**
- [ ] TerrainVisualConfig contains per-type base_color[10] and emissive_color_intensity[10] (Vec4 with rgb + intensity)
- [ ] Config integrated with ToonShaderConfig singleton (ticket 2-008)
- [ ] Uniform buffer updated when config changes
- [ ] Changes take effect immediately (live tuning during development)
- [ ] Default values match Game Designer and Graphics Engineer specified values
- [ ] Glow behavior parameters (pulse speed, shimmer intensity) also configurable
- [ ] Config can be loaded from file for rapid iteration

**Dependencies:**
- Blocked by: 3-026 (terrain shader reads this config), Epic 2 ticket 2-008 (ToonShaderConfig)
- Blocks: None

**Agent Notes:**
- Graphics Engineer: This is the artistic tuning interface. Base colors should be dark tones with distinct hues. Emissive values from canon v0.5.0 art direction are starting points, not final values.
- Game Designer: The 2-second identification rule: any terrain type identifiable within 2 seconds from any camera angle. This config enables tuning to achieve that.

---

### Ticket 3-040: Glow Color Specification and Tuning Data

**Type:** task
**System:** Cross-System
**Group:** J
**Estimated Scope:** S
**Status:** NEW

**Description:**
Define and document the exact glow colors, patterns, and animation parameters for all 10 terrain types. This is the design specification that feeds into TerrainVisualConfig (ticket 3-039) and TerrainTypeInfo (ticket 3-003). Includes base color hex, emissive color hex, emissive intensity, glow behavior type, pulse period, and bloom contribution description.

**Acceptance Criteria:**
- [ ] All 10 terrain types documented with: base color (dark tone hex), emissive color (hex), emissive intensity (0.0-1.0), glow behavior (static/pulse/shimmer/flow/irregular), pulse period (seconds), bloom contribution (none/minimal/low/medium/high)
- [ ] Color palette has no two types sharing the same primary emissive hue
- [ ] Intensity hierarchy validated: substrate(0.05) < ridge(0.10) < water(0.10-0.15) < grove(0.25) < spore(0.30) < ember(0.35) < blight(0.30) < prisma(0.60)
- [ ] Pattern differentiation for color-impaired players (veining vs pulsing vs flowing vs geometric)
- [ ] Distance readability verified: types distinguishable by color at max zoom-out
- [ ] Values entered into TerrainTypeInfo static table and TerrainVisualConfig

**Dependencies:**
- Blocked by: None (design specification)
- Blocks: 3-003 (TerrainTypeInfo values), 3-039 (TerrainVisualConfig values)

**Agent Notes:**
- Game Designer: This is the visual readability specification. Every terrain type occupies a unique hue band. The palette is designed against the dark base environment. Substrate barely visible, PrismaFields dramatic. Color language must be consistent between terrain, minimap, and overlays.
- Graphics Engineer: Values from this ticket populate the shader uniform buffers. PrismaFields at 0.60 is highest terrain emissive, intentionally below building glow (0.5-1.0).

---

## Dependency Graph

```
LEGEND:
  [3-NNN] = Epic 3 ticket
  {2-NNN} = Epic 2 dependency
  --> = "blocks" (arrow points to dependent)

GROUP A: Data Infrastructure
  [3-001] TerrainType/Component
    |--> [3-002] TerrainGrid
    |      |--> [3-006] Water Distance Field
    |      |--> [3-007] Seeded RNG/Noise ---+
    |      |--> [3-014] ITerrainQueryable   |
    |      |--> [3-016] ITerrainRenderData  |
    |      |--> [3-017] ITerrainModifier    |
    |      |--> [3-027] Water Mesh          |
    |      '--> [3-036] Serialization       |
    |--> [3-003] TerrainTypeInfo            |
    |      |--> [3-014] ITerrainQueryable   |
    |      |--> [3-025] Chunk Mesh Gen      |
    |      |--> [3-029] Vegetation Place    |
    |      |--> [3-030] Vegetation Render   |
    |      '--> [3-040] Glow Spec           |
    |--> [3-004] TerrainModifiedEvent       |
    |      |--> [3-019] Purge               |
    |      |--> [3-020] Grade               |
    |      |--> [3-025] Chunk Mesh Gen      |
    |      '--> [3-031] Visual Update       |
    |--> [3-005] Water Body IDs             |
    |      |--> [3-009] Water Generation    |
    |      |--> [3-027] Water Mesh          |
    |      '--> [3-028] Water Shader        |
    '--> [3-010] Biome Distribution         |
                                            |
GROUP B: Procedural Generation              |
  [3-007] Seeded RNG/Noise <----------------+
    |--> [3-008] Elevation Heightmap
    |      |--> [3-009] Water Body Gen
    |      |      |--> [3-010] Biome Distribution
    |      |      |      |--> [3-012] Spawn Points
    |      |      |      |      '--> [3-013] Map Validation
    |      |      |      '--> [3-013]
    |      |      '--> [3-013]
    |      '--> [3-012]
    |--> [3-009]
    '--> [3-010]

GROUP C: Query API
  [3-014] ITerrainQueryable
    '--> [3-015] Batch Queries

  [3-016] ITerrainRenderData
    |--> [3-025] Chunk Mesh Gen
    |--> [3-027] Water Mesh
    |--> [3-029] Vegetation Placement
    '--> [3-031] Visual Update

  [3-017] ITerrainModifier
    |--> [3-019] Purge
    |--> [3-020] Grade
    '--> [3-021] Terraform

GROUP D: Terrain Modification
  [3-019] Purge --> [3-022] Auth/Network --> [3-037] Network Sync
  [3-020] Grade --> [3-022]
  [3-021] Terraform (depends on [3-019])

GROUP E: Terrain Mesh Rendering
  {2-003} + {2-010} --> [3-023] Vertex Format
    '--> [3-024] Normal Calculation
          '--> [3-025] Chunk Mesh Generator (CRITICAL PATH)
                |--> [3-031] Visual Update
                |--> [3-032] LOD Mesh Gen
                |      '--> [3-033] LOD Seam Mitigation
                |--> [3-034] Frustum Culling Integration
                '--> [3-038] Debug Visualizations

  {2-005} + {2-037} --> [3-026] Terrain Fragment Shader
    '--> [3-031] Visual Update

GROUP F: Water Rendering
  [3-027] Water Mesh --> [3-028] Water Shader

GROUP G: Vegetation
  [3-029] Vegetation Placement --> [3-030] Vegetation Instanced Render

GROUP I: Serialization
  [3-036] Serialization --> [3-037] Network Sync
```

### Critical Path

The minimum path to "terrain visible on screen":

1. **3-001** TerrainType/Component (S)
2. **3-002** TerrainGrid (M)
3. **3-007** Seeded RNG/Noise (M)
4. **3-008** Elevation Heightmap (L)
5. **3-003** TerrainTypeInfo (S) [parallel with 3-008 after 3-001]
6. **3-004** TerrainModifiedEvent (S) [parallel]
7. **3-016** ITerrainRenderData (M)
8. **3-023** Terrain Vertex Format (M) [requires Epic 2: 2-003, 2-010]
9. **3-024** Normal Calculation (S)
10. **3-025** Chunk Mesh Generator (XL) -- **critical bottleneck**
11. **3-026** Terrain Fragment Shader (L) [requires Epic 2: 2-005, 2-037]

After the critical path, parallel tracks open:
- **Water track:** 3-005 -> 3-009 -> 3-027 -> 3-028
- **Vegetation track:** 3-029 -> 3-030
- **Modification track:** 3-017 -> 3-019/3-020/3-021 -> 3-022
- **Performance track:** 3-032 -> 3-033, 3-034
- **Serialization track:** 3-036 -> 3-037
- **Polish track:** 3-038, 3-039, 3-040

### Cross-Epic Dependencies

| Epic 2 Ticket | Epic 3 Consumer | Reason |
|---------------|----------------|--------|
| 2-001 through 2-007 | 3-023, 3-025, 3-026 | GPU device, pipeline, shader for terrain mesh rendering |
| 2-005 (Toon Shader) | 3-026 | Base toon shader that terrain shader extends |
| 2-006 (Edge Detection) | 3-035 | Edge detection tuning for terrain boundaries |
| 2-008 (ToonShaderConfig) | 3-039 | Runtime config for terrain visual parameters |
| 2-009 (glTF Loading) | 3-030 | Load vegetation/crystal models |
| 2-010 (GPU Mesh) | 3-023 | GPU buffer creation infrastructure |
| 2-012 (GPU Instancing) | 3-030 | Instanced vegetation rendering |
| 2-016 (Transparent Handling) | 3-028 | Water rendered as semi-transparent |
| 2-026 (Frustum Culling) | 3-034 | Chunk-based frustum culling |
| 2-029, 2-030 (Ray Casting, Tile Picking) | N/A | Epic 2 needs get_elevation() from Epic 3 for heightmap ray casting |
| 2-034 (Render Layers) | 3-028 | Water in WATER layer |
| 2-037 (Emissive Support) | 3-026 | Terrain emissive material pipeline |
| 2-038 (Bloom) | 3-026 | Terrain glow feeds bloom pass |
| 2-040 (Debug Grid) | 3-038 | Debug overlay infrastructure |
| 2-049 (LOD Framework) | 3-032 | Terrain LOD level selection |
| 2-050 (Spatial Partitioning) | 3-034 | Chunk registration for culling |

**Circular dependency note:** Epic 2 ticket 2-030 (Tile Picking) needs terrain elevation for heightmap ray casting. Resolution: Epic 2 implements flat-plane picking first; Epic 3 exposes get_elevation(); then picking is updated to use actual elevation. This is a soft dependency, not a blocker.

---

## Ticket Count Summary

| Group | Count | Description |
|-------|-------|-------------|
| A: Data Infrastructure | 7 | TerrainType, TerrainGrid, TerrainTypeInfo, Events, Water IDs, Distance Field, Noise |
| B: Procedural Generation | 6 | Elevation, Water, Biomes, Scaling, Spawns, Validation |
| C: Query API and Interfaces | 4 | ITerrainQueryable, Batch Queries, ITerrainRenderData, ITerrainModifier |
| D: Terrain Modification | 5 | Contamination, Purge, Grade, Terraform, Network Authority |
| E: Terrain Mesh Rendering | 4 | Vertex Format, Normals, Chunk Generator, Fragment Shader |
| F: Water Rendering | 2 | Water Mesh, Water Shader |
| G: Vegetation/Decoration | 2 | Placement Generator, Instanced Rendering |
| H: Performance Integration | 5 | Visual Update, LOD Meshes, LOD Seams, Culling, Edge Tuning |
| I: Serialization/Multiplayer | 2 | Save/Load, Network Sync |
| J: Visual Polish/Debug | 3 | Debug Views, Visual Config, Glow Specification |
| **Total** | **40** | |

**Size Distribution:**
| Size | Count |
|------|-------|
| S | 9 |
| M | 17 |
| L | 10 |
| XL | 4 |

---

## Notes

- Epic 2 rendering infrastructure must be substantially complete before terrain can be visible. Groups A-D (data + generation + queries + modification) can proceed in parallel with Epic 2 development.
- The TerrainSystem is the first system bridging game state to GPU rendering -- the patterns established here (ITerrainRenderData, chunk dirty tracking, event-driven rebuild) will be reused by every subsequent visual system.
- Deterministic cross-platform generation (ticket 3-007) is the highest technical risk in this epic. Golden output CI tests are mandatory.
- Water body generation (ticket 3-009) is the highest design risk -- convincing rivers are notoriously difficult to generate procedurally.
- The query API (ticket 3-014) must be locked down during Epic 3 planning. At least 6 downstream systems depend on its stability.
- All player-facing text must use canonical alien terminology (substrate, ridges, deep void, flow channel, still basin, biolume grove, prisma fields, spore flats, blight mires, ember crust).
- Map seed is visible after game start (pause menu, post-game summary), NOT during initial site selection, to preserve the discovery experience.
- Sea level is NOT player-adjustable. Reserved for disaster events in Epic 13.
- Audio cues per terrain type (crystal hum, bubbling, flowing water, wind) are deferred to audio epic -- noted here for future reference.
- Terrain scan layer overlays (type, elevation, buildability, contamination) are deferred to Epic 12 (UI System) -- data queries (ticket 3-014, 3-015) support them.
